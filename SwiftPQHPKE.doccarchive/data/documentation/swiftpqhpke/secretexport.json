{"primaryContentSections":[{"kind":"content","content":[{"text":"","type":"heading","anchor":"","level":2},{"text":"Single Secret Export","type":"heading","anchor":"Single-Secret-Export","level":3},{"type":"paragraph","inlineContent":[{"type":"text","text":"Given the recipient’s public key, a "},{"type":"codeVoice","code":"CipherSuite"},{"type":"text","text":" instance can generate a secret that only the recipient can know."}]},{"type":"paragraph","inlineContent":[{"type":"strong","inlineContent":[{"text":"Example","type":"text"}]}]},{"type":"codeListing","syntax":"swift","code":["\/\/ Generate secret in base mode","","import SwiftPQHPKE","","\/\/ The aead need not be .EXPORTONLY, any aead will work","","\/\/ The CipherSuite to use","let theSuite = CipherSuite(kem: .ML512, kdf: .KDF256, aead: .EXPORTONLY)","","\/\/ The recipient keys","let (recipientPubKey, recipientPrivKey) = theSuite.makeKeyPair()","","\/\/ Generate the secret","let (encapsulated, secret) = try theSuite.sendExport(publicKey: recipientPubKey, info: [], context: [], L: 10)","print(\"Generated secret:\", secret)","","\/\/ The recipient retrieves the secret by means of the encapsulated key","let retrievedSecret = try theSuite.receiveExport(privateKey: recipientPrivKey, info: [], context: [], L: 10, encap: encapsulated)","print(\"Retrieved secret:\", retrievedSecret)"]},{"type":"paragraph","inlineContent":[{"type":"text","text":"giving (for example):"}]},{"type":"codeListing","syntax":"swift","code":["Generated secret: [214, 237, 48, 14, 75, 122, 60, 137, 232, 222]","Retrieved secret: [214, 237, 48, 14, 75, 122, 60, 137, 232, 222]"]},{"text":"Multi-secret Export","type":"heading","anchor":"Multi-secret-Export","level":3},{"type":"paragraph","inlineContent":[{"type":"text","text":"Given the recipient’s public key, a "},{"type":"codeVoice","code":"Sender"},{"type":"text","text":" instance can generate secrets that only the recipient can know."}]},{"type":"paragraph","inlineContent":[{"inlineContent":[{"type":"text","text":"Example"}],"type":"strong"}]},{"type":"codeListing","syntax":"swift","code":["\/\/ Generate 3 secrets in preshared key mode","","import SwiftPQHPKE","","\/\/ The aead need not be .EXPORTONLY, any aead will work","","\/\/ The CipherSuite to use","let theSuite = CipherSuite(kem: .ML512, kdf: .KDF256, aead: .EXPORTONLY)","","let thePsk: Bytes = [1]","let thePskId: Bytes = [2]","let theInfo: Bytes = [1, 2, 3]","","\/\/ The Recipient keys","let (recipientPubKey, recipientPrivKey) = theSuite.makeKeyPair()","","\/\/ Create the Sender instance","let sender = try Sender(suite: theSuite, publicKey: recipientPubKey, info: theInfo, psk: thePsk, pskId: thePskId)","","let ctx1: Bytes = [1]","let ctx2: Bytes = [2]","let ctx3: Bytes = [3]","","\/\/ Generate the secrets","let secret1 = try sender.sendExport(context: ctx1, L: 10)","let secret2 = try sender.sendExport(context: ctx2, L: 10)","let secret3 = try sender.sendExport(context: ctx3, L: 10)","print(\"Generated secret1:\", secret1)","print(\"Generated secret2:\", secret2)","print(\"Generated secret3:\", secret3)","print()","","\/\/ Create the Recipient instance, the recipient retrieves the secrets by means of the encapsulated key","let recipient = try Recipient(suite: theSuite, privateKey: recipientPrivKey, info: theInfo, psk: thePsk, pskId: thePskId, encap: sender.encapsulatedKey)","","\/\/ Retrieve the secrets","let retrievedSecret1 = try recipient.receiveExport(context: ctx1, L: 10)","let retrievedSecret2 = try recipient.receiveExport(context: ctx2, L: 10)","let retrievedSecret3 = try recipient.receiveExport(context: ctx3, L: 10)","print(\"Retrieved secret1:\", retrievedSecret1)","print(\"Retrieved secret2:\", retrievedSecret2)","print(\"Retrieved secret3:\", retrievedSecret3)"]},{"type":"paragraph","inlineContent":[{"type":"text","text":"giving (for example):"}]},{"type":"codeListing","syntax":"swift","code":["Generated secret1: [69, 227, 178, 197, 20, 38, 132, 235, 147, 90]","Generated secret2: [165, 213, 95, 210, 19, 71, 144, 70, 189, 32]","Generated secret3: [98, 6, 38, 67, 130, 142, 230, 207, 1, 128]","","Retrieved secret1: [69, 227, 178, 197, 20, 38, 132, 235, 147, 90]","Retrieved secret2: [165, 213, 95, 210, 19, 71, 144, 70, 189, 32]","Retrieved secret3: [98, 6, 38, 67, 130, 142, 230, 207, 1, 128]"]}]}],"schemaVersion":{"major":0,"patch":0,"minor":3},"hierarchy":{"paths":[["doc:\/\/swiftpqhpke.SwiftPQHPKE\/documentation\/SwiftPQHPKE"]]},"metadata":{"roleHeading":"Article","title":"Secret Export","role":"article","modules":[{"name":"SwiftPQHPKE"}]},"kind":"article","identifier":{"url":"doc:\/\/swiftpqhpke.SwiftPQHPKE\/documentation\/SwiftPQHPKE\/SecretExport","interfaceLanguage":"swift"},"abstract":[{"text":"Create secret messages","type":"text"}],"seeAlsoSections":[{"title":"Additional Information","identifiers":["doc:\/\/swiftpqhpke.SwiftPQHPKE\/documentation\/SwiftPQHPKE\/EncryptDecrypt","doc:\/\/swiftpqhpke.SwiftPQHPKE\/documentation\/SwiftPQHPKE\/KeyManagement","doc:\/\/swiftpqhpke.SwiftPQHPKE\/documentation\/SwiftPQHPKE\/Performance","doc:\/\/swiftpqhpke.SwiftPQHPKE\/documentation\/SwiftPQHPKE\/References"],"generated":true,"anchor":"Additional-Information"}],"variants":[{"paths":["\/documentation\/swiftpqhpke\/secretexport"],"traits":[{"interfaceLanguage":"swift"}]}],"sections":[],"references":{"doc://swiftpqhpke.SwiftPQHPKE/documentation/SwiftPQHPKE":{"identifier":"doc:\/\/swiftpqhpke.SwiftPQHPKE\/documentation\/SwiftPQHPKE","title":"SwiftPQHPKE","kind":"symbol","abstract":[{"type":"text","text":"Post-Quantum Hybrid Public Key Encryption"}],"url":"\/documentation\/swiftpqhpke","type":"topic","role":"collection"},"doc://swiftpqhpke.SwiftPQHPKE/documentation/SwiftPQHPKE/EncryptDecrypt":{"identifier":"doc:\/\/swiftpqhpke.SwiftPQHPKE\/documentation\/SwiftPQHPKE\/EncryptDecrypt","title":"Encryption and Decryption","role":"article","type":"topic","kind":"article","url":"\/documentation\/swiftpqhpke\/encryptdecrypt","abstract":[{"text":"Encrypt and decrypt one or more messages","type":"text"}]},"doc://swiftpqhpke.SwiftPQHPKE/documentation/SwiftPQHPKE/Performance":{"url":"\/documentation\/swiftpqhpke\/performance","kind":"article","title":"Performance","type":"topic","identifier":"doc:\/\/swiftpqhpke.SwiftPQHPKE\/documentation\/SwiftPQHPKE\/Performance","abstract":[{"text":"Encryption and decryption speed","type":"text"}],"role":"article"},"doc://swiftpqhpke.SwiftPQHPKE/documentation/SwiftPQHPKE/References":{"title":"References","type":"topic","identifier":"doc:\/\/swiftpqhpke.SwiftPQHPKE\/documentation\/SwiftPQHPKE\/References","url":"\/documentation\/swiftpqhpke\/references","kind":"article","abstract":[{"type":"text","text":"Algorithms from the following papers have been used in the implementation"}],"role":"article"},"doc://swiftpqhpke.SwiftPQHPKE/documentation/SwiftPQHPKE/KeyManagement":{"kind":"article","identifier":"doc:\/\/swiftpqhpke.SwiftPQHPKE\/documentation\/SwiftPQHPKE\/KeyManagement","role":"article","title":"Key Management","url":"\/documentation\/swiftpqhpke\/keymanagement","type":"topic","abstract":[{"text":"Create new keys and load existing keys","type":"text"}]}}}